<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style>
body {background-color: LightCyan;}
h1   {color: blue;}
</style>
</head>
<body>
<h1>红黑树(RBTree)的分析和实现</h1><p>
From http://blog.csdn.net/hxxiaopei/article/details/1413993<p>
<address>&nbsp;&nbsp;标签：
              insertdeletesearchstructtreeclass
            
        
        
            2006-11-25 16:53
            2760人阅读
             评论(1)
             收藏
              举报</address><p>

<p>二叉排序树在查找方面提供了很大的方便，但是对worst-case查找/插入/删除/求最值&nbsp;得时间复杂度都为O(n).</p>
<p>红黑树可以保证在worst-case下查找/插入/删除等的复杂度得到O(lgN)。红黑树保持如下特性：</p>
<p>1。节点不是red 就是black</p>
<p>2。root为black</p>
<p>3。所有的leaf为black</p>
<p>4。所有red node 的孩子为black</p>
<p>5。任一node通过左子树和右子树到达叶子节点的black node个数相同</p>
<p>可以证明 红黑树的最大高度为2lg(N+1)，所以在红黑树上的操作的时间复杂度为O(lgN)。 其插入和删除操作的时间复杂度都是O(lgN),插入最多需要2次旋转，删除最多需要3次旋转。</p>
<p>其插入和删除操作可能会与红黑树的特性相违背，所以需要修正。在具体的实现中 1）插入的节点都是red。如果其父节点为red,就违背了条件4&nbsp; 2)如果删除的节点为black，违背了条件5需要修正。3）需要一个NIL来表示叶子节点，共享该叶子节点，且为root的父节点，节省空间。 </p>
<p>提供了查找 插入 删除 后继 最值操作。</p>
<p>具体实现：</p>
<p>//implement red-black tree<br />/*<br />*xiaopei<br />*06/11/24<br />*/<br />#ifndef RBTREE_H<br />#define RBTREE_H<br />template &lt;typename Type&gt;<br />struct TreeNode<br />{<br />&nbsp;&nbsp;Type key;<br />&nbsp;&nbsp;int color;&nbsp;<br />&nbsp;&nbsp;TreeNode *parent,*left,*right;<br />};<br />template &lt;typename Type&gt;<br />class RBTree<br />{<br />private:<br />&nbsp;enum<br />&nbsp;{<br />&nbsp;&nbsp;RED,BLACK<br />&nbsp;}Color;<br />&nbsp;Type key;<br />&nbsp;int color;&nbsp;<br />&nbsp;TreeNode&lt;Type&gt; *parent,*left,*right;<br />&nbsp;TreeNode&lt;Type&gt; *NIL;//<br />&nbsp;TreeNode&lt;Type&gt; *ROOT;<br />&nbsp;void left_rotate(TreeNode&lt;Type&gt; *&amp;rotate);<br />&nbsp;void right_rotate(TreeNode&lt;Type&gt; *&amp;rotate);<br />&nbsp;void RB_insert_fixup(TreeNode&lt;Type&gt;* &amp;node);<br />&nbsp;void RB_delete_fixup(TreeNode&lt;Type&gt;* &amp;node);<br />public:<br />&nbsp;//const static TreeNode&lt;Type&gt;* nil;<br />&nbsp;RBTree();<br />&nbsp;TreeNode&lt;Type&gt; *successor(const TreeNode&lt;Type&gt; *node);<br />&nbsp;TreeNode&lt;Type&gt;* insert(Type key);<br />&nbsp;TreeNode&lt;Type&gt;* search(Type key);<br />&nbsp;TreeNode&lt;Type&gt;* remove(Type key);<br />&nbsp;TreeNode&lt;Type&gt; *maxnum(TreeNode&lt;Type&gt;*node);<br />&nbsp;TreeNode&lt;Type&gt;* minnum(TreeNode&lt;Type&gt;*node);<br />&nbsp;TreeNode&lt;Type&gt;* getRoot();<br />&nbsp;void inorder(TreeNode&lt;Type&gt;*node);<br />&nbsp;void test()<br />&nbsp;{<br />&nbsp;&nbsp;this-&gt;insert(1);<br />&nbsp;&nbsp;this-&gt;insert(2);<br />&nbsp;&nbsp;left_rotate(ROOT);<br />&nbsp;}<br />&nbsp;~RBTree();<br />};<br />//template &lt;typename Type&gt;<br />//const&nbsp; TreeNode&lt;Type&gt;* RBTree&lt;Type&gt;::nil=NIL;<br />template &lt;typename Type&gt;<br />RBTree&lt;Type&gt;::RBTree()<br />{<br />&nbsp;NIL=new TreeNode&lt;Type&gt;;<br />&nbsp;NIL-&gt;color=BLACK;<br />&nbsp;NIL-&gt;key=123456;<br />&nbsp;NIL-&gt;left=0;<br />&nbsp;NIL-&gt;right=0;<br />&nbsp;NIL-&gt;parent=0;<br />&nbsp;ROOT=NIL;<br />}<br />template&lt;typename Type&gt;<br />RBTree&lt;Type&gt;::~RBTree()<br />{<br />&nbsp;delete NIL;<br />}<br />template&lt;typename Type&gt;<br />TreeNode&lt;Type&gt;* RBTree&lt;Type&gt;::maxnum(TreeNode&lt;Type&gt;*node)<br />{<br />&nbsp;//如果是空树怎么办？<br />&nbsp;TreeNode&lt;Type&gt; *max=node;<br />&nbsp;while(max-&gt;right!=NIL)<br />&nbsp;&nbsp;max=max-&gt;right;<br />&nbsp;return max;<br />}<br />template&lt;typename Type&gt;<br />TreeNode&lt;Type&gt;*&nbsp; RBTree&lt;Type&gt;::minnum(TreeNode&lt;Type&gt;*node)<br />{<br />&nbsp;//如果是空树怎么办？<br />&nbsp;TreeNode&lt;Type&gt; *min=node;<br />&nbsp;&nbsp;while(min-&gt;left!=NIL)<br />&nbsp;&nbsp;&nbsp;min=min-&gt;left;<br />&nbsp;return min;<br />}<br />template&lt;typename Type&gt;<br />TreeNode&lt;Type&gt;* RBTree&lt;Type&gt;::successor(const TreeNode&lt;Type&gt;* node)<br />{</p>
<p>&nbsp;if(node-&gt;right!=NIL)<br />&nbsp;&nbsp;return minnum(node-&gt;right);<br />&nbsp; const TreeNode&lt;Type&gt;*s=node;<br />&nbsp; const TreeNode&lt;Type&gt;*p=s-&gt;parent;<br />&nbsp; while(p!=NIL&amp;&amp;s==p-&gt;right){s=p;p=s-&gt;parent;}<br />&nbsp;return const_cast&lt;TreeNode&lt;Type&gt;*&gt;(p);<br />}<br />template&lt;typename Type&gt;<br />TreeNode&lt;Type&gt;* RBTree&lt;Type&gt;::getRoot()<br />{<br />&nbsp;TreeNode&lt;Type&gt;*root=ROOT;<br />&nbsp;return root;<br />}<br />template&lt;typename Type&gt;<br />void&nbsp; RBTree&lt;Type&gt;::left_rotate(TreeNode&lt;Type&gt;*&amp; _rotate)<br />{<br />&nbsp;if(_rotate-&gt;right==NIL){cout&lt;&lt;&quot;没有右孩子，不能左旋&quot;;return ;}//right child is nil, so can not left rotate</p>
<p>&nbsp;TreeNode&lt;Type&gt;* r = _rotate-&gt;right;<br />&nbsp;TreeNode&lt;Type&gt;*t,*rotate=_rotate;<br />&nbsp;//deal with r-&gt;left<br />&nbsp;rotate-&gt;right=r-&gt;left;<br />&nbsp;r-&gt;left-&gt;parent=rotate;<br />&nbsp;<br />&nbsp;//deal with r<br />//&nbsp;t=rotate-&gt;parent;<br />&nbsp;//&nbsp;r-&gt;parent=t;//rotate 被修改成了NIL 为什么？<br />//&nbsp;rotate=rotate-&gt;parent;<br />&nbsp;if(rotate-&gt;parent==NIL)<br />&nbsp;{ROOT=r;r-&gt;parent=NIL;}<br />&nbsp;else if(rotate==rotate-&gt;parent-&gt;left)<br />&nbsp;&nbsp;rotate-&gt;parent-&gt;left=r;<br />&nbsp;else<br />&nbsp;&nbsp;rotate-&gt;parent-&gt;right=r;<br />&nbsp;r-&gt;parent=rotate-&gt;parent;<br />&nbsp;//deal with rotate<br />&nbsp;rotate-&gt;parent=r;<br />&nbsp;r-&gt;left=rotate;<br />}<br />template&lt;typename Type&gt;<br />void&nbsp; RBTree&lt;Type&gt;::right_rotate(TreeNode&lt;Type&gt;* &amp;_rotate)<br />{<br />&nbsp;TreeNode&lt;Type&gt;*rotate=_rotate;//不知道为什么，如果直接对_rotate操作，在过程中会改变_rotate得值<br />&nbsp;if(rotate-&gt;left==NIL)return ;//left child is NIL, so can not right rotate<br />&nbsp;TreeNode&lt;Type&gt;* l = rotate-&gt;left;<br />&nbsp;//deal with l-&gt;right<br />&nbsp;//cout&lt;&lt;&quot;key&quot;&lt;&lt;rotate-&gt;parent-&gt;key&lt;&lt;endl;<br />&nbsp;l-&gt;right-&gt;parent=rotate;<br />&nbsp;rotate-&gt;left=l-&gt;right;<br />&nbsp;//deal with l<br />&nbsp;l-&gt;parent=rotate-&gt;parent;<br />&nbsp;if(rotate-&gt;parent==NIL)<br />&nbsp;{ROOT=l;l-&gt;parent=NIL;}<br />&nbsp;else if(rotate==rotate-&gt;parent-&gt;left)<br />&nbsp;&nbsp;rotate-&gt;parent-&gt;left=l;<br />&nbsp;else<br />&nbsp;&nbsp;rotate-&gt;parent-&gt;right=l;<br />&nbsp;//deal with rotate<br />&nbsp;rotate-&gt;parent=l;<br />&nbsp;l-&gt;right=rotate;<br />}<br />template&lt;typename Type&gt;<br />TreeNode&lt;Type&gt;* RBTree&lt;Type&gt;::insert(Type key)<br />{<br />&nbsp;TreeNode&lt;Type&gt; *node=new TreeNode&lt;Type&gt;;</p>
<p>&nbsp;TreeNode&lt;Type&gt; *down=ROOT;<br />&nbsp;TreeNode&lt;Type&gt; *s=NIL;<br />&nbsp;while(down!=NIL)<br />&nbsp;{<br />&nbsp;&nbsp;s=down;<br />&nbsp;&nbsp;if(key&lt;down-&gt;key)<br />&nbsp;&nbsp;&nbsp;down=down-&gt;left;<br />&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;down=down-&gt;right;<br />&nbsp;}//找到合适位置<br />&nbsp;node-&gt;parent=s;<br />&nbsp;if(s==NIL)<br />&nbsp;{ROOT=node;node-&gt;parent=NIL;}<br />&nbsp;else if(key&lt;s-&gt;key)<br />&nbsp;&nbsp;s-&gt;left=node;<br />&nbsp;else<br />&nbsp;&nbsp;s-&gt;right=node;<br />&nbsp;node-&gt;key=key;<br />&nbsp;node-&gt;left=NIL;<br />&nbsp;node-&gt;right=NIL;<br />&nbsp;node-&gt;color=RED;</p>
<p>&nbsp;RB_insert_fixup(node);<br />&nbsp;return node;<br />}<br />template&lt;typename Type&gt;<br />void RBTree&lt;Type&gt;::RB_insert_fixup(TreeNode&lt;Type&gt;*&amp; change)<br />{<br />//&nbsp;TreeNode&lt;Type&gt;*change=node;<br />&nbsp;TreeNode&lt;Type&gt;*father;<br />&nbsp;&nbsp;TreeNode&lt;Type&gt;*uncle;<br />&nbsp;while(change-&gt;parent-&gt;color==RED)<br />&nbsp;{<br />&nbsp;&nbsp;father=change-&gt;parent;<br />&nbsp;&nbsp;if(father==father-&gt;parent-&gt;left)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;uncle=father-&gt;parent-&gt;right;//父节点的兄弟<br />&nbsp;&nbsp;&nbsp;if(uncle-&gt;color==RED)//uncle同样为red<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;uncle-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;parent-&gt;color=RED;<br />&nbsp;&nbsp;&nbsp;&nbsp;change=father-&gt;parent;//进行循环<br />&nbsp;&nbsp;&nbsp;}else <br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;//cout&lt;&lt;&quot;uncle node color=black&quot;&lt;&lt;endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(change==father-&gt;right)//内插入，左旋<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change=father;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//cout&lt;&lt;&quot;before rotate key:&quot;&lt;&lt;change-&gt;key&lt;&lt;&quot; color &quot;&lt;&lt;change-&gt;color&lt;&lt;endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left_rotate(change);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;father=change-&gt;parent;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//cout&lt;&lt;&quot;after rotate key:&quot;&lt;&lt;change-&gt;key&lt;&lt;&quot; color &quot;&lt;&lt;change-&gt;color&lt;&lt;endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;cout&lt;&lt;&quot;内插入&quot;&lt;&lt;endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;//外插入<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;parent-&gt;color=RED;//改变颜色<br />&nbsp;&nbsp;&nbsp;//&nbsp;cout&lt;&lt;&quot;before rotate key:&quot;&lt;&lt;change-&gt;key&lt;&lt;&quot; color &quot;&lt;&lt;change-&gt;color&lt;&lt;endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;right_rotate(father-&gt;parent);<br />&nbsp;&nbsp;&nbsp;//&nbsp;cout&lt;&lt;&quot;before rotate key:&quot;&lt;&lt;change-&gt;key&lt;&lt;&quot; color &quot;&lt;&lt;change-&gt;color&lt;&lt;endl;<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;else<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;uncle=father-&gt;parent-&gt;left;//父节点的兄弟<br />&nbsp;&nbsp;&nbsp;if(uncle-&gt;color==RED)//uncle同样为red<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;uncle-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;parent-&gt;color=RED;<br />&nbsp;&nbsp;&nbsp;&nbsp;change=father-&gt;parent;//进行循环<br />&nbsp;&nbsp;&nbsp;}else<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if(change==father-&gt;left)//内插入<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change=father;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right_rotate(change);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;father=change-&gt;parent;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;//外插入<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;parent-&gt;color=RED;<br />&nbsp;&nbsp;&nbsp;&nbsp;left_rotate(father-&gt;parent);<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;}<br />&nbsp;}<br />&nbsp;ROOT-&gt;color=BLACK;<br />}<br />template&lt;typename Type&gt;<br />TreeNode&lt;Type&gt;* RBTree&lt;Type&gt;::search(Type key)<br />{<br />&nbsp;TreeNode&lt;Type&gt; *p=ROOT;<br />&nbsp;while(p!=NIL&amp;&amp;p-&gt;key!=key)<br />&nbsp;{<br />&nbsp;&nbsp;if(key&lt;p-&gt;key)<br />&nbsp;&nbsp;&nbsp;p=p-&gt;left;<br />&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;p=p-&gt;right;<br />&nbsp;}<br />&nbsp;return p;<br />}<br />template&lt;typename Type&gt;<br />TreeNode&lt;Type&gt;* RBTree&lt;Type&gt;::remove(Type key)<br />{<br />&nbsp;TreeNode&lt;Type&gt; *p = this-&gt;search(key);<br />&nbsp;if(p==NIL)<br />&nbsp;&nbsp;return p;<br />&nbsp;//rn 为需要改变的节点，找到得key节点，如果只有一个孩子或者没有孩子，则需要被删除的就是该节点，否则（两个孩子）<br />&nbsp;//需要删除的是直接后继节点（首先将key节点用后继节点代替）后继节点没有左孩子<br />&nbsp;//最后rn最多只有一个孩子<br />&nbsp;TreeNode&lt;Type&gt; *rn=NIL;<br />&nbsp;TreeNode&lt;Type&gt; *act;<br />&nbsp;if(p-&gt;left==NIL || p-&gt;right==NIL)<br />&nbsp;&nbsp;rn=p;<br />&nbsp;else<br />&nbsp;&nbsp;rn = this-&gt;successor(p);<br />&nbsp;if(rn-&gt;left!=NIL)//如果被删除的节点左孩子不空，则使用act纪录(key节点只有左孩子的情况)<br />&nbsp;&nbsp;act=rn-&gt;left;<br />&nbsp;else//act纪录key没有孩子，有右孩子，双子情况<br />&nbsp;&nbsp;act=rn-&gt;right;<br />&nbsp;<br />&nbsp;act-&gt;parent=rn-&gt;parent;//更新父节点<br />&nbsp;if(rn-&gt;parent==NIL)<br />&nbsp;&nbsp;ROOT=act;//已经将act得parent修改成NIL了<br />&nbsp;else if(rn == rn-&gt;parent-&gt;left)<br />&nbsp;&nbsp;rn-&gt;parent-&gt;left=act;<br />&nbsp;else<br />&nbsp;&nbsp;rn-&gt;parent-&gt;right=act;<br />&nbsp;if(rn!=p)//key有两个孩子时，实际删除的是p的直接后继rn节点，所以需要将后继节点的信息复制key节点中<br />&nbsp;&nbsp;p-&gt;key=rn-&gt;key;<br />&nbsp;if(rn-&gt;color==BLACK)<br />&nbsp;&nbsp;RB_delete_fixup(act);<br />&nbsp;return rn;<br />}<br />//删除一个黑色节点后导致两边的bh不同。<br />template&lt;typename Type&gt;<br />void RBTree&lt;Type&gt;::RB_delete_fixup(TreeNode&lt;Type&gt; *&amp;_node)<br />{</p>
<p>&nbsp;TreeNode&lt;Type&gt;*father,*brother,*node;<br />&nbsp;node=_node;<br />&nbsp;father=node-&gt;parent;<br />&nbsp;while(node!=ROOT&amp;&amp;node-&gt;color==BLACK)//如果color(x)为red，只需要讲color(x)=black就行了<br />&nbsp;{<br />&nbsp;&nbsp;if(node=father-&gt;left)//color(node)=black,father左孩子得black nodes(m-1) =father右孩子的black nodes(m) -1<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;brother=father-&gt;right;<br />&nbsp;&nbsp;&nbsp;if(brother-&gt;color==RED)//color(father)=black,********************case 1<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;brother-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;color=RED;<br />&nbsp;&nbsp;&nbsp;&nbsp;left_rotate(father);//修改了树结构,这一步后brother为node得祖父节点并且brother右孩子的black nodes = m不变<br />&nbsp;&nbsp;&nbsp;&nbsp;brother=parent-&gt;right;//修正node得兄弟节点，现在color(father)=black right(father)=black,并且father-&gt;left得<br />&nbsp;&nbsp;&nbsp;&nbsp;//black nodes还为m-1,father-&gt;right得black nodes = m<br />&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;//如果兄弟为黑，则根据兄弟的孩子来区分,color(Node)=black,color(brother)=black,color(father)未知</p>
<p>&nbsp;&nbsp;&nbsp;if(brother-&gt;left-&gt;color==BLACK&amp;&amp;brother-&gt;right-&gt;color==BLACK)//********************case 2<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;brother-&gt;color=RED;//fater右孩子的black nodes = m-1<br />&nbsp;&nbsp;&nbsp;&nbsp;node=father;//如果father为red，则循环结束，将father改为black，则整个以father为根的子树左右孩子的black nodes都为m<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;else <br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if(brother-&gt;right-&gt;color==BLACK)//右孩子为黑色********************case 3<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother-&gt;left-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother-&gt;color=RED;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right_rotate(brother);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother=father-&gt;right;//brother的右孩子为red<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;//if(brother-&gt;right-&gt;color==RED)************************case 4<br />&nbsp;&nbsp;&nbsp;&nbsp;father-&gt;color=BLACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;brother-&gt;right-&gt;color=BLACK;//red修改成black<br />&nbsp;&nbsp;&nbsp;&nbsp;brother-&gt;color=father-&gt;color;<br />&nbsp;&nbsp;&nbsp;&nbsp;//执行旋转后，brother为node得祖父，brother右孩子得black nodes=m,做孩子的black nodes=m(+father为黑色)<br />&nbsp;&nbsp;&nbsp;&nbsp;left_rotate(father);<br />&nbsp;&nbsp;&nbsp;&nbsp;node=ROOT;//结束<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;}<br />&nbsp;}<br />&nbsp;node-&gt;color=BLACK;<br />}<br />template&lt;typename Type&gt;<br />void RBTree&lt;Type&gt;::inorder(TreeNode&lt;Type&gt;*node)<br />{<br />&nbsp;if(node!=NIL)<br />&nbsp;{<br />&nbsp;&nbsp;inorder(node-&gt;left);<br />&nbsp;&nbsp;if(node-&gt;color==RED)<br />&nbsp;&nbsp;&nbsp;if(node-&gt;left-&gt;color==RED||node-&gt;right-&gt;color==RED)<br />&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;&quot;wrong&quot;&lt;&lt;&quot; &quot;;<br />&nbsp;&nbsp;cout&lt;&lt;node-&gt;key&lt;&lt;&quot; &quot;;<br />&nbsp;&nbsp;inorder(node-&gt;right);<br />&nbsp;}<br />&nbsp;<br />}<br />#endif</p>
<p>&nbsp;</p>   

</body>
</html>
